<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interaction · Makie.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Makie.jl logo"/></a><h1>Makie.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="basic-tutorials.html">Tutorial</a></li><li><a class="toctext" href="help_functions.html">Help functions</a></li><li><a class="toctext" href="functions-overview.html">Atomic functions overview</a></li><li><a class="toctext" href="signatures.html">Plot function signatures</a></li><li><a class="toctext" href="plot-attributes.html">Plot attributes</a></li><li><a class="toctext" href="axis.html">Axis</a></li><li class="current"><a class="toctext" href="interaction.html">Interaction</a><ul class="internal"><li><a class="toctext" href="#Tutorial:-interaction-pipeline-1">Tutorial: interaction pipeline</a></li><li><a class="toctext" href="#Animation-using-time-1">Animation using time</a></li><li><a class="toctext" href="#Interaction-using-the-mouse-1">Interaction using the mouse</a></li><li><a class="toctext" href="#Correct-way-to-animate-a-plot-1">Correct way to animate a plot</a></li></ul></li><li><a class="toctext" href="output.html">Output</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="index-examples.html">Examples index</a></li><li><a class="toctext" href="examples-heatmap.html"><code>heatmap</code></a></li><li><a class="toctext" href="examples-image.html"><code>image</code></a></li><li><a class="toctext" href="examples-lines.html"><code>lines</code></a></li><li><a class="toctext" href="examples-linesegments.html"><code>linesegments</code></a></li><li><a class="toctext" href="examples-mesh.html"><code>mesh</code></a></li><li><a class="toctext" href="examples-meshscatter.html"><code>meshscatter</code></a></li><li><a class="toctext" href="examples-scatter.html"><code>scatter</code></a></li><li><a class="toctext" href="examples-surface.html"><code>surface</code></a></li><li><a class="toctext" href="examples-text.html"><code>text</code></a></li><li><a class="toctext" href="examples-volume.html"><code>volume</code></a></li><li><a class="toctext" href="examples-contour.html"><code>contour</code></a></li><li><a class="toctext" href="examples-arrows.html"><code>arrows</code></a></li><li><a class="toctext" href="examples-barplot.html"><code>barplot</code></a></li><li><a class="toctext" href="examples-poly.html"><code>poly</code></a></li><li><a class="toctext" href="examples-band.html"><code>band</code></a></li><li><a class="toctext" href="examples-slider.html"><code>slider</code></a></li><li><a class="toctext" href="examples-vbox.html"><code>vbox</code></a></li><li><a class="toctext" href="examples-interaction.html"><code>interaction</code></a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="why-makie.html">Why <code>Makie</code>?</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Basics</li><li><a href="interaction.html">Interaction</a></li></ul><a class="edit-page" href="https://github.com/JuliaPlots/Makie.jl/blob/master/docs/src/interaction.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Interaction</span><a class="fa fa-bars" href="#"></a></div></header><div></div><div></div><div></div><h1><a class="nav-anchor" id="Interaction-1" href="#Interaction-1">Interaction</a></h1><p>Makie offers a sophisticated referencing system to share attributes across the Scene in your plot. This is great for animations and saving resources – also if the backend decides to put data on the GPU you might even share those in GPU memory.</p><p>Animations in Makie are handled by using <code>Reactive.jl</code> signals. These signals are called <code>Node</code>s in Makie, and can be continuously updated by pushing a value to it. See below for a brief tutorial about the signals pipeline.</p><h2><a class="nav-anchor" id="Tutorial:-interaction-pipeline-1" href="#Tutorial:-interaction-pipeline-1">Tutorial: interaction pipeline</a></h2><p>First, create a <code>Node</code>:</p><div><pre><code class="language-julia">x = Node(0.0) # set up a Node, and give it a default value of 0.0</code></pre><pre><code class="language-none">Observables.Observable{Float64}(&quot;ob_2901&quot;, 0.0, Any[])</code></pre></div><p>Note that <code>Reactive</code> also assigns an ID and a unique name to the Node. You can then derive a signal off of the value of the Node by using <code>lift</code>:</p><div><pre><code class="language-julia">f(a) = a^2
y = lift(a -&gt; f(a), x)</code></pre><pre><code class="language-none">Observables.Observable{Float64}(&quot;ob_2902&quot;, 0.0, Any[])</code></pre></div><p>Now, for every value of the Node <code>x</code>, the derived Node <code>y</code> will hold the value <code>f(x)</code>.</p><p>To update the value of the Node, <code>push!</code> to it:</p><div><pre><code class="language-julia">push!(x, 5.0)</code></pre><pre><code class="language-none">5.0</code></pre></div><p>Note how the value of <code>y</code> has been changed as well, in addition to <code>x</code>:</p><div><pre><code class="language-julia">for i in (x, y)
    println(to_value(i))
end</code></pre><pre><code class="language-none">5.0
25.0</code></pre></div><p>That is to say, the Node <code>y</code> maps the function <code>f</code> (which is <code>a -&gt; a^2</code> in this case) on <code>x</code> whenever the Node <code>x</code> is updated, and returns the corresponding signal to <code>y</code>. This is the basis of signal updating, and is used for updating plots in Makie. Any plot created based on this pipeline system will get updated whenever the Nodes it is based on are updated.</p><p>Note: for now, <code>lift</code> is just an alias for <code>Reactive.map</code>, and <code>Node</code> is just an alias for <code>Reactive.Signal</code>.</p><p>For more information, check out <a href="https://juliagizmos.github.io/Reactive.jl/"><code>Reactive.jl</code>&#39;s documentation</a>.</p><h2><a class="nav-anchor" id="Animation-using-time-1" href="#Animation-using-time-1">Animation using time</a></h2><p>To animate a scene, you need to create a <code>Node</code>, e.g.:</p><pre><code class="language-julia">time = Node(0.0)</code></pre><p>and use <code>lift</code> on the Node to set up a pipeline to access its value. For example:</p><pre><code class="language-julia">scene = Scene()
time = Node(0.0)
myfunc(v, t) = sin.(v, t)

scene = lines!(
    scene,
    lift(t -&gt; f.(range(0, stop=2pi, length=50), t), time)
)</code></pre><p>now, whenever the Node <code>time</code> is updated (e.g. when you <code>push!</code> to it), the plot will also be updated.</p><pre><code class="language-julia">push!(time, Base.time())</code></pre><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><div><pre><code class="language-julia">using Makie

 N = 100
 scene = scatter([0], [0], marker = &#39;❤&#39;, markersize = 0.5, color = :red, raw = true)
 s = scene[end] # last plot in scene
 record(scene, &quot;C:\\Users\\sdani\\.julia\\dev\\Makie\\docs\\media\\pulsing_marker.mp4&quot;, range(0, stop = 10pi, length = N)) do i
     s[:markersize] = (cos(i) + 1) / 4 + 0.2
end

</code></pre></div>    <video controls autoplay loop muted>
      <source src="media\pulsing_marker.mp4" type="video/mp4">
      Your browser does not support mp4. Please use a modern browser like Chrome or Firefox.
    </video>


<div><pre><code class="language-julia">using Makie

 scene = Scene()
 f(t, v, s) = (sin(v + t) * s, cos(v + t) * s)
 time_node = Node(0.0)
 p1 = scatter!(scene, lift(t-&gt; f.(t, range(0, stop = 2pi, length = 50), 1), time_node))[end]
 p2 = scatter!(scene, lift(t-&gt; f.(t * 2.0, range(0, stop = 2pi, length = 50), 1.5), time_node))[end]
 points = lift(p1[1], p2[1]) do pos1, pos2
     map((a, b)-&gt; (a, b), pos1, pos2)
 end
 linesegments!(scene, points)
 N = 150
 record(scene, &quot;C:\\Users\\sdani\\.julia\\dev\\Makie\\docs\\media\\interaction.mp4&quot;, range(0, stop = 10, length = N)) do i
     push!(time_node, i)
end

</code></pre></div>    <video controls autoplay loop muted>
      <source src="media\interaction.mp4" type="video/mp4">
      Your browser does not support mp4. Please use a modern browser like Chrome or Firefox.
    </video>


<div><pre><code class="language-julia">using Makie

 xyvec = rand(Point2f0, (2)) .* 5 .+ 1
 velvec = rand(Point2f0, (2)) .* 10
 # define some other parameters
 t = 0
 ts = 0.03
 balldiameter = 1
 origin = Point2f0(0, 0)
 xybounds = Point2f0(10, 10)
 N = 200
 scene = scatter(
     xyvec,
     markersize = balldiameter,
     color = rand(RGBf0, 2),
     limits = FRect(0, 0, xybounds)
 )
 s = scene[end] # last plot in scene

 record(scene, &quot;C:\\Users\\sdani\\.julia\\dev\\Makie\\docs\\media\\pong.mp4&quot;, 1:N) do i
     # calculate new ball position
     global t = t + ts
     global xyvec = xyvec .+ velvec .* ts
     global velvec = map(xyvec, xybounds, origin, velvec) do p, b, o, vel
         boolvec = ((p .+ balldiameter/2) .&gt; b) .| ((p .- balldiameter/2) .&lt; o)
         velvec = map(boolvec, vel) do b, v
             b ? -v : v
         end
     end
     # plot
     s[1] = xyvec
end

</code></pre></div>    <video controls autoplay loop muted>
      <source src="media\pong.mp4" type="video/mp4">
      Your browser does not support mp4. Please use a modern browser like Chrome or Firefox.
    </video>


<h2><a class="nav-anchor" id="Interaction-using-the-mouse-1" href="#Interaction-using-the-mouse-1">Interaction using the mouse</a></h2><p>A few default Nodes are already implemented in a <code>scene</code>&#39;s Events (see them in <code>scene.events</code>), so to use them in your interaction pipeline, you can simply <code>lift</code> them.</p><p>For example, for interaction with the mouse cursor, <code>lift</code> the <code>mouseposition</code> signal.</p><pre><code class="language-julia">pos = lift(scene.events.mouseposition) do mpos
    # do stuff
end</code></pre><h3><a class="nav-anchor" id="Examples-2" href="#Examples-2">Examples</a></h3><div><pre><code class="language-julia">using Makie
 using LinearAlgebra

 scene = Scene(raw = true, camera = cam2d!, resolution = (500, 500))
 r = range(0, stop = 3, length = 4)
 the_time = Node(time())
 last_open = false
 @async while true
     global last_open
     the_time[] = time()
     # this is a bit awkward, since the isopen(scene) is false
     # as long as the scene isn&#39;t displayed
     last_open &amp;&amp; !isopen(scene) &amp;&amp; break
     last_open = isopen(scene)
     sleep(1/25)
 end
 pos = lift(scene.events.mouseposition, the_time) do mpos, t
     map(LinRange(0, 2pi, 60)) do i
         circle = Point2f0(sin(i), cos(i))
         mouse = to_world(scene, Point2f0(mpos))
         secondary = (sin((i * 10f0) + t) * 0.09) * normalize(circle)
         (secondary .+ circle) .+ mouse
     end
 end
 lines!(scene, pos)
 p1 = scene[end]
 p2 = scatter!(
     scene,
     pos, markersize = 0.1f0,
     marker = :star5,
     color = p1[:color],
 )[end]
 center!(scene)
 t = Theme(raw = true, camera = campixel!)
 b1 = button(t, &quot;color&quot;)
 b2 = button(t, &quot;marker&quot;)
 msize = slider(t, 0.1:0.01:0.5)
 on(b1[end][:clicks]) do c
     p1[:color] = rand(RGBAf0)
 end
 markers = (&#39;π&#39;, &#39;😹&#39;, &#39;⚃&#39;, &#39;◑&#39;, &#39;▼&#39;)
 on(b2[end][:clicks]) do c
     p2[:marker] = markers[rand(1:5)]
 end
 on(msize[end][:value]) do val
     p2[:markersize] = val
 end
 RecordEvents(hbox(
     vbox(b1, b2, msize),
     scene
 ), &quot;C:\\Users\\sdani\\.julia\\dev\\Makie\\docs\\media\\interaction_with_mouse&quot;)

</code></pre></div>    <video controls autoplay loop muted>
      <source src="media\interaction_with_mouse.mp4" type="video/mp4">
      Your browser does not support mp4. Please use a modern browser like Chrome or Firefox.
    </video>


<p>For more examples, consult the <a href="index-examples.html#Examples-index-1">Examples index</a>.</p><h2><a class="nav-anchor" id="Correct-way-to-animate-a-plot-1" href="#Correct-way-to-animate-a-plot-1">Correct way to animate a plot</a></h2><p>You can animate a plot in a <code>for</code> loop:</p><pre><code class="language-julia">r = 1:10
for i = 1:length(r)
    push!(s[:markersize], r[i])
    AbstractPlotting.force_update!()
    sleep(1/24)
end</code></pre><p>But, if you <code>push!</code> to a plot, it doesn&#39;t necessarily get updated whenever an attribute changes, so you must call <code>force_update!()</code>.</p><p>A better way to do it is to access the attribute of a plot directly using its symbol, and when you change it, the plot automatically gets updated live, so you no longer need to call <code>force_update!()</code>:</p><pre><code class="language-julia">for i = 1:length(r)
    s[:markersize] = r[i]
    # AbstractPlotting.force_update!() is no longer needed
    sleep(1/24)
end</code></pre><p>Similarly, for plots based on functions:</p><pre><code class="language-julia">scene = Scene()
v = range(0, stop=4pi, length=50)
f(v, t) = sin(v + t) # some function
s = lines!(
    scene,
    lift(t -&gt; f.(v, t), time),
)[end];

for i = 1:length(v)
    push!(time, i)
    sleep(1/24)
end</code></pre><footer><hr/><a class="previous" href="axis.html"><span class="direction">Previous</span><span class="title">Axis</span></a><a class="next" href="output.html"><span class="direction">Next</span><span class="title">Output</span></a></footer></article></body></html>
