<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interaction · Makie.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Makie.jl logo"/></a><h1>Makie.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="help_functions.html">Help functions</a></li><li><a class="toctext" href="functions-overview.html">Atomic functions overview</a></li><li><a class="toctext" href="signatures.html">Plot function signatures</a></li><li><a class="toctext" href="attributes.html">Plot attributes</a></li><li class="current"><a class="toctext" href="interaction.html">Interaction</a><ul class="internal"><li><a class="toctext" href="#Tutorial:-interaction-pipeline-1">Tutorial: interaction pipeline</a></li><li><a class="toctext" href="#Animation-using-time-1">Animation using time</a></li><li><a class="toctext" href="#Interaction-using-the-mouse-1">Interaction using the mouse</a></li><li><a class="toctext" href="#Correct-way-to-animate-a-plot-1">Correct way to animate a plot</a></li></ul></li><li><a class="toctext" href="output.html">Output</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="index-examples.html">Examples index</a></li><li><a class="toctext" href="examples-heatmap.html"><code>heatmap</code></a></li><li><a class="toctext" href="examples-image.html"><code>image</code></a></li><li><a class="toctext" href="examples-lines.html"><code>lines</code></a></li><li><a class="toctext" href="examples-linesegments.html"><code>linesegments</code></a></li><li><a class="toctext" href="examples-mesh.html"><code>mesh</code></a></li><li><a class="toctext" href="examples-meshscatter.html"><code>meshscatter</code></a></li><li><a class="toctext" href="examples-scatter.html"><code>scatter</code></a></li><li><a class="toctext" href="examples-surface.html"><code>surface</code></a></li><li><a class="toctext" href="examples-text.html"><code>text</code></a></li><li><a class="toctext" href="examples-volume.html"><code>volume</code></a></li><li><a class="toctext" href="examples-contour.html"><code>contour</code></a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Basics</li><li><a href="interaction.html">Interaction</a></li></ul><a class="edit-page" href="https://github.com/JuliaPlots/Makie.jl/blob/master/docs/src/interaction.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Interaction</span><a class="fa fa-bars" href="#"></a></div></header><div></div><div></div><div></div><h1><a class="nav-anchor" id="Interaction-1" href="#Interaction-1">Interaction</a></h1><p>Makie offers a sophisticated referencing system to share attributes across the Scene in your plot. This is great for animations and saving resources – also if the backend decides to put data on the GPU you might even share those in GPU memory.</p><p>Animations in Makie are handled by using <code>Reactive.jl</code> signals. These signals are called <code>Node</code>s in Makie, and can be continuously updated by pushing a value to it. See below for a brief tutorial about the signals pipeline.</p><h2><a class="nav-anchor" id="Tutorial:-interaction-pipeline-1" href="#Tutorial:-interaction-pipeline-1">Tutorial: interaction pipeline</a></h2><p>First, create a <code>Node</code>:</p><div><pre><code class="language-julia">x = Node(0.0) # set up a Node, and give it a default value of 0.0</code></pre><pre><code class="language-none">29648: &quot;input-4795&quot; = 0.0 Float64</code></pre></div><p>Note that <code>Reactive</code> also assigns an ID and a unique name to the Node. You can then derive a signal off of the value of the Node by using <code>lift</code>:</p><div><pre><code class="language-julia">f(a) = a^2
y = lift(a -&gt; f(a), x)</code></pre><pre><code class="language-none">29649: &quot;map(input-4795)&quot; = 0.0 Float64</code></pre></div><p>Now, for every value of the Node <code>x</code>, the derived Node <code>y</code> will hold the value <code>f(x)</code>.</p><p>To update the value of the Node, <code>push!</code> to it:</p><div><pre><code class="language-julia">push!(x, 5.0)</code></pre></div><p>Note how the value of <code>y</code> has been changed as well, in addition to <code>x</code>:</p><div><pre><code class="language-julia">for i in (x, y)
    println(i.value)
end</code></pre><pre><code class="language-none">5.0
25.0</code></pre></div><p>That is to say, the Node <code>y</code> maps the function <code>f</code> (which is <code>a -&gt; a^2</code> in this case) on <code>x</code> whenever the Node <code>x</code> is updated, and returns the corresponding signal to <code>y</code>. This is the basis of signal updating, and is used for updating plots in Makie. Any plot created based on this pipeline system will get updated whenever the Nodes it is based on are updated.</p><p>Note: for now, <code>lift</code> is just an alias for <code>Reactive.map</code>, and <code>Node</code> is just an alias for <code>Reactive.Signal</code>.</p><p>For more information, check out <a href="https://juliagizmos.github.io/Reactive.jl/"><code>Reactive.jl</code>&#39;s documentation</a>.</p><h2><a class="nav-anchor" id="Animation-using-time-1" href="#Animation-using-time-1">Animation using time</a></h2><p>To animate a scene, you need to create a <code>Node</code>, e.g.:</p><pre><code class="language-julia">time = Node(0.0)</code></pre><p>and use <code>lift</code> on the Node to set up a pipeline to access its value. For example:</p><pre><code class="language-julia">scene = Scene()
time = Node(0.0)
myfunc(v, t) = sin.(v, t)

scene = lines!(
    scene,
    lift(t -&gt; f.(linspace(0, 2pi, 50), t), time)
)</code></pre><p>now, whenever the Node <code>time</code> is updated (e.g. when you <code>push!</code> to it), the plot will also be updated.</p><pre><code class="language-julia">push!(time, Base.time())</code></pre><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><div><pre><code class="language-julia">using Makie

N = 100
r = [cos(i)+1 for i = linspace(0, 10pi, N)] ./ 5 + 1
scene = scatter([0], [0], marker = &#39;❤&#39;, markersize = 0.5, color = :red, raw = true)
scene
s = scene[end] # last plot in scene
record(scene, &quot;C:\\Users\\sdani\\.julia\\v0.6\\Makie\\docs\\media\\pulsing_marker.mp4&quot;, r) do i
    push!(s[:markersize], i)
end

</code></pre></div><div><pre><code class="language-julia">using Makie

scene = Scene(resolution = (500, 500))

f(t, v, s) = (sin(v + t) * s, cos(v + t) * s)
time = Node(0.0)
p1 = scatter!(scene, lift(t-&gt; f.(t, linspace(0, 2pi, 50), 1), time))[end]
p2 = scatter!(scene, lift(t-&gt; f.(t * 2.0, linspace(0, 2pi, 50), 1.5), time))[end]
lines = lift(p1[1], p2[1]) do pos1, pos2
    map((a, b)-&gt; (a, b), pos1, pos2)
end
linesegments!(scene, lines)
N = 150
record(scene, &quot;C:\\Users\\sdani\\.julia\\v0.6\\Makie\\docs\\media\\interaction.mp4&quot;, linspace(0, 10, N)) do i
    push!(time, i)
end

</code></pre></div><h2><a class="nav-anchor" id="Interaction-using-the-mouse-1" href="#Interaction-using-the-mouse-1">Interaction using the mouse</a></h2><p>A few default Nodes are already implemented in a <code>scene</code>&#39;s Events (see them in <code>scene.events</code>), so to use them in your interaction pipeline, you can simply <code>lift</code> them.</p><p>For example, for interaction with the mouse cursor, <code>lift</code> the <code>mouseposition</code> signal.</p><pre><code class="language-julia">pos = lift(scene.events.mouseposition) do mpos
    # do stuff
end</code></pre><h3><a class="nav-anchor" id="Examples-2" href="#Examples-2">Examples</a></h3><div><pre><code class="language-julia">using Makie

scene = Scene()
r = linspace(0, 3, 4)
cam2d!(scene)
time = Node(0.0)
pos = lift(scene.events.mouseposition, time) do mpos, t
    map(linspace(0, 2pi, 60)) do i
        circle = Point2f0(sin(i), cos(i))
        mouse = to_world(scene, Point2f0(mpos))
        secondary = (sin((i * 10f0) + t) * 0.09) * normalize(circle)
        (secondary .+ circle) .+ mouse
    end
end
scene = lines!(scene, pos, raw = true)
p1 = scene[end]
p2 = scatter!(
    scene,
    pos, markersize = 0.1f0,
    marker = :star5,
    color = p1[:color],
    raw = true
)[end]
scene
display(Makie.global_gl_screen(), scene)

p1[:color] = RGBAf0(1, 0, 0, 0.1)
p2[:marker] = &#39;π&#39;
p2[:markersize] = 0.2

# push a reasonable mouse position in case this is executed as part
# of the documentation
push!(scene.events.mouseposition, (250.0, 250.0))
N = 50
record(scene, &quot;C:\\Users\\sdani\\.julia\\v0.6\\Makie\\docs\\media\\interaction_with_mouse.mp4&quot;, linspace(0.01, 0.4, N)) do i
    push!(scene.events.mouseposition, (250.0, 250.0))
    p2[:markersize] = i
    push!(time, time[] + 0.1)
end

</code></pre></div><p>For more examples, consult the <a href="index-examples.html#Examples-index-1">Examples index</a>.</p><h2><a class="nav-anchor" id="Correct-way-to-animate-a-plot-1" href="#Correct-way-to-animate-a-plot-1">Correct way to animate a plot</a></h2><p>You can animate a plot in a <code>for</code> loop:</p><pre><code class="language-julia">r = 1:10
for i = 1:length(r)
    push!(s[:markersize], r[i])
    AbstractPlotting.force_update!()
    sleep(1/24)
end</code></pre><p>But, if you <code>push!</code> to a plot, it doesn&#39;t necessarily get updated whenever an attribute changes, so you must call <code>force_update!()</code>.</p><p>A better way to do it is to access the attribute of a plot directly using its symbol, and when you change it, the plot automatically gets updated live, so you no longer need to call <code>force_update!()</code>:</p><pre><code class="language-julia">for i = 1:length(r)
    s[:markersize] = r[i]
    # AbstractPlotting.force_update!() is no longer needed
    sleep(1/24)
end</code></pre><p>Similarly, for plots based on functions:</p><pre><code class="language-julia">scene = Scene()
v = linspace(0, 4pi, 50)
f(v, t) = sin(v + t) # some function
s = lines!(
    scene,
    lift(t -&gt; f.(v, t), time),
)[end];

for i = 1:length(v)
    push!(time, i)
    sleep(1/24)
end</code></pre><footer><hr/><a class="previous" href="attributes.html"><span class="direction">Previous</span><span class="title">Plot attributes</span></a><a class="next" href="output.html"><span class="direction">Next</span><span class="title">Output</span></a></footer></article></body></html>
