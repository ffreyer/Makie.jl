<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>meshscatter · Makie.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Makie.jl logo"/></a><h1>Makie.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="basic-tutorials.html">Tutorial</a></li><li><a class="toctext" href="help_functions.html">Help functions</a></li><li><a class="toctext" href="functions-overview.html">Atomic functions overview</a></li><li><a class="toctext" href="signatures.html">Plot function signatures</a></li><li><a class="toctext" href="plot-attributes.html">Plot attributes</a></li><li><a class="toctext" href="axis.html">Axis</a></li><li><a class="toctext" href="interaction.html">Interaction</a></li><li><a class="toctext" href="output.html">Output</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="index-examples.html">Examples index</a></li><li><a class="toctext" href="examples-heatmap.html"><code>heatmap</code></a></li><li><a class="toctext" href="examples-image.html"><code>image</code></a></li><li><a class="toctext" href="examples-lines.html"><code>lines</code></a></li><li><a class="toctext" href="examples-linesegments.html"><code>linesegments</code></a></li><li><a class="toctext" href="examples-mesh.html"><code>mesh</code></a></li><li class="current"><a class="toctext" href="examples-meshscatter.html"><code>meshscatter</code></a><ul class="internal"><li><a class="toctext" href="#Orthographic-Camera-1">Orthographic Camera</a></li><li><a class="toctext" href="#Meshscatter-Function-1">Meshscatter Function</a></li><li><a class="toctext" href="#Record-Video-1">Record Video</a></li><li><a class="toctext" href="#Fluctuation-3D-1">Fluctuation 3D</a></li><li><a class="toctext" href="#Simple-meshscatter-1">Simple meshscatter</a></li><li><a class="toctext" href="#Explicit-frame-rendering-1">Explicit frame rendering</a></li><li><a class="toctext" href="#GUI-for-exploring-Lorenz-equation-1">GUI for exploring Lorenz equation</a></li><li><a class="toctext" href="#Type-recipe-for-molecule-simulation-1">Type recipe for molecule simulation</a></li></ul></li><li><a class="toctext" href="examples-scatter.html"><code>scatter</code></a></li><li><a class="toctext" href="examples-surface.html"><code>surface</code></a></li><li><a class="toctext" href="examples-text.html"><code>text</code></a></li><li><a class="toctext" href="examples-volume.html"><code>volume</code></a></li><li><a class="toctext" href="examples-contour.html"><code>contour</code></a></li><li><a class="toctext" href="examples-arrows.html"><code>arrows</code></a></li><li><a class="toctext" href="examples-barplot.html"><code>barplot</code></a></li><li><a class="toctext" href="examples-poly.html"><code>poly</code></a></li><li><a class="toctext" href="examples-band.html"><code>band</code></a></li><li><a class="toctext" href="examples-slider.html"><code>slider</code></a></li><li><a class="toctext" href="examples-vbox.html"><code>vbox</code></a></li><li><a class="toctext" href="examples-interaction.html"><code>interaction</code></a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="why-makie.html">Why <code>Makie</code>?</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href="examples-meshscatter.html"><code>meshscatter</code></a></li></ul><a class="edit-page" href="https://github.com/JuliaPlots/Makie.jl/blob/master/docs/src/examples-meshscatter.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>meshscatter</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="meshscatter-1" href="#meshscatter-1"><code>meshscatter</code></a></h1><h2><a class="nav-anchor" id="Orthographic-Camera-1" href="#Orthographic-Camera-1">Orthographic Camera</a></h2><p>Tags: <code>3d</code>, <code>cameracontrols</code>, <code>meshscatter</code>, <code>update_cam</code>.</p><pre><code class="language-julia">using Makie
 using GeometryTypes

 x = Vec3f0(0); baselen = 0.2f0; dirlen = 1f0
 # create an array of differently colored boxes in the direction of the 3 axes
 rectangles = [
     (FRect3D(Vec3f0(x), Vec3f0(dirlen, baselen, baselen)), RGBAf0(1,0,0,1)),
     (FRect3D(Vec3f0(x), Vec3f0(baselen, dirlen, baselen)), RGBAf0(0,1,0,1)),
     (FRect3D(Vec3f0(x), Vec3f0(baselen, baselen, dirlen)), RGBAf0(0,0,1,1))
 ]
 meshes = map(GLNormalMesh, rectangles)
 scene = mesh(merge(meshes))
 display(scene)
 cam = Makie.cameracontrols(scene)
 dir = scene.limits[].widths ./ 2.
 dir_scaled = Vec3f0(
     dir[1] * scene.transformation.scale[][1],
     0.0,
     dir[3] * scene.transformation.scale[][2],
 )
 cam.upvector[] = (0.0, 0.0, 1.0)
 cam.lookat[] = scene.limits[].origin + dir_scaled
 cam.eyeposition[] = (cam.lookat[][1], cam.lookat[][2] + 6.3, cam.lookat[][3])
 cam.projectiontype[] = AbstractPlotting.Orthographic
 update_cam!(scene, cam)
 # stop scene display from centering, which would overwrite the camera paramter we just set
 scene.center = false
 scene

</code></pre><p><img src="media/orthographic_camera.jpg" alt="library lines 28:53"/></p><h2><a class="nav-anchor" id="Meshscatter-Function-1" href="#Meshscatter-Function-1">Meshscatter Function</a></h2><p>Tags: <code>3d</code>, <code>meshscatter</code>.</p><pre><code class="language-julia">using Makie
 using GeometryTypes

 large_sphere = Sphere(Point3f0(0), 1f0)
 positions = decompose(Point3f0, large_sphere)
 colS = [RGBAf0(rand(), rand(), rand(), 1.0) for i = 1:length(positions)]
 sizesS = [rand(Point3f0) .* 0.05f0 for i = 1:length(positions)]
 meshscatter(positions, color = colS, markersize = sizesS)

</code></pre><p><img src="media/meshscatter_function.jpg" alt="library lines 132:137"/></p><h2><a class="nav-anchor" id="Record-Video-1" href="#Record-Video-1">Record Video</a></h2><p>Tags: <code>3d</code>, <code>linesegment</code>, <code>meshscatter</code>, <code>record</code>.</p><pre><code class="language-julia">using Makie

 scene = Scene()

 f(t, v, s) = (sin(v + t) * s, cos(v + t) * s, (cos(v + t) + sin(v)) * s)
 t = Node(Base.time()) # create a life signal
 limits = FRect3D(Vec3f0(-1.5, -1.5, -3), Vec3f0(3, 3, 6))
 p1 = meshscatter!(scene, lift(t-&gt; f.(t, range(0, stop = 2pi, length = 50), 1), t), markersize = 0.05)[end]
 p2 = meshscatter!(scene, lift(t-&gt; f.(t * 2.0, range(0, stop = 2pi, length = 50), 1.5), t), markersize = 0.05)[end]

 lines = lift(p1[1], p2[1]) do pos1, pos2
     map((a, b)-&gt; (a, b), pos1, pos2)
 end
 linesegments!(scene, lines, linestyle = :dot, limits = limits)
 # record a video
 N = 150
 record(scene, &quot;./docs/media/record_video.mp4&quot;, 1:N) do i
     push!(t, Base.time())
end

</code></pre>    <video controls autoplay loop muted>
      <source src="media\record_video.mp4" type="video/mp4">
      Your browser does not support mp4. Please use a modern browser like Chrome or Firefox.
    </video><h2><a class="nav-anchor" id="Fluctuation-3D-1" href="#Fluctuation-3D-1">Fluctuation 3D</a></h2><p>Tags: <code>3d</code>, <code>animated</code>, <code>axis</code>, <code>mesh</code>, <code>meshscatter</code>.</p><pre><code class="language-julia">using Makie
 using GeometryTypes, Colors

 scene = Scene()
 # define points/edges
 perturbfactor = 4e1
 N = 3; nbfacese = 30; radius = 0.02
 large_sphere = Sphere(Point3f0(0), 1f0)
 positions = decompose(Point3f0, large_sphere, 30)
 np = length(positions)
 pts = [positions[k][l] for k = 1:length(positions), l = 1:3]
 pts = vcat(pts, 1.1 .* pts + randn(size(pts)) / perturbfactor) # light position influence ?
 edges = hcat(collect(1:np), collect(1:np) .+ np)
 ne = size(edges, 1); np = size(pts, 1)
 # define markers meshes
 meshC = GLNormalMesh(
     Makie.Cylinder{3, Float32}(
         Point3f0(0., 0., 0.),
         Point3f0(0., 0, 1.),
         Float32(1)
     ), nbfacese
 )
 meshS = GLNormalMesh(large_sphere, 20)
 # define colors, markersizes and rotations
 pG = [Point3f0(pts[k, 1], pts[k, 2], pts[k, 3]) for k = 1:np]
 lengthsC = sqrt.(sum((pts[edges[:,1], :] .- pts[edges[:, 2], :]) .^ 2, dims = 2))
 sizesC = [Vec3f0(radius, radius, lengthsC[i]) for i = 1:ne]
 sizesC = [Vec3f0(1., 1., 1.) for i = 1:ne]
 colorsp = [RGBA{Float32}(rand(), rand(), rand(), 1.) for i = 1:np]
 colorsC = [(colorsp[edges[i, 1]] .+ colorsp[edges[i, 2]]) / 2.0 for i = 1:ne]
 sizesC = [Vec3f0(radius, radius, lengthsC[i]) for i = 1:ne]
 Qlist = zeros(ne, 4)
 for k = 1:ne
     ct = GeometryTypes.Cylinder{3, Float32}(
         Point3f0(pts[edges[k, 1], 1], pts[edges[k, 1], 2], pts[edges[k, 1], 3]),
         Point3f0(pts[edges[k, 2], 1], pts[edges[k, 2], 2], pts[edges[k, 2], 3]),
         Float32(1)
     )
     Q = GeometryTypes.rotation(ct)
     r = 0.5 * sqrt(1 .+ Q[1, 1] .+ Q[2, 2] .+ Q[3, 3]); Qlist[k, 4] = r
     Qlist[k, 1] = (Q[3, 2] .- Q[2, 3]) / (4 .* r)
     Qlist[k, 2] = (Q[1, 3] .- Q[3, 1]) / (4 .* r)
     Qlist[k, 3] = (Q[2, 1] .- Q[1, 2]) / (4 .* r)
 end
 rotationsC = [Vec4f0(Qlist[i, 1], Qlist[i, 2], Qlist[i, 3], Qlist[i, 4]) for i = 1:ne]
 # plot
 hm = meshscatter!(
     scene, pG[edges[:, 1]],
     color = colorsC, marker = meshC,
     markersize = sizesC,  rotations = rotationsC,
 )
 hp = meshscatter!(
     scene, pG,
     color = colorsp, marker = meshS, markersize = radius,
 )

</code></pre><p><img src="media/fluctuation_3d.jpg" alt="library lines 329:378"/></p><h2><a class="nav-anchor" id="Simple-meshscatter-1" href="#Simple-meshscatter-1">Simple meshscatter</a></h2><p>Tags: <code>3d</code>, <code>meshscatter</code>.</p><pre><code class="language-julia">using Makie

 large_sphere = Sphere(Point3f0(0), 1f0)
 positions = decompose(Point3f0, large_sphere)
 meshscatter(positions, color = RGBAf0(0.9, 0.2, 0.4, 1), markersize = 0.05)

</code></pre><p><img src="media/simple_meshscatter.jpg" alt="library lines 404:406"/></p><h2><a class="nav-anchor" id="Explicit-frame-rendering-1" href="#Explicit-frame-rendering-1">Explicit frame rendering</a></h2><p>Tags: <code>3d</code>, <code>meshscatter</code>, <code>opengl</code>, <code>render_frame</code>.</p><pre><code class="language-julia">using Makie
 using ModernGL, Makie
 using GLFW

 Makie.GLMakie.opengl_renderloop[] = (screen) -&gt; nothing
 function update_loop(m, buff, screen)
     for i = 1:20
         GLFW.PollEvents()
         buff .= rand.(Point3f0) .* 20f0
         m[1] = buff
         Makie.GLMakie.render_frame(screen)
         GLFW.SwapBuffers(Makie.GLMakie.to_native(screen))
         glFinish()
     end
 end
 scene = meshscatter(rand(Point3f0, 10^4) .* 20f0)
 display(scene)
 meshplot = scene[end]
 buff = rand(Point3f0, 10^4) .* 20f0;
 screen = Makie.GLMakie.global_gl_screen();
 @time update_loop(meshplot, buff, screen)
 Makie.GLMakie.opengl_renderloop[] = Makie.GLMakie.renderloop # restore previous loop
 # when done:
 Makie.GLMakie.destroy!(screen)
 scene

</code></pre><p><img src="media/explicit_frame_rendering.jpg" alt="library lines 575:597"/></p><h2><a class="nav-anchor" id="GUI-for-exploring-Lorenz-equation-1" href="#GUI-for-exploring-Lorenz-equation-1">GUI for exploring Lorenz equation</a></h2><p>Tags: <code>colorswatch</code>, <code>hbox</code>, <code>interaction</code>, <code>meshscatter</code>, <code>record_events</code>, <code>slider</code>, <code>textslider</code>, <code>vbox</code>.</p><pre><code class="language-julia">using Makie
 using Colors, Makie
 using AbstractPlotting: textslider, colorswatch

 s1, a = textslider(0f0:50f0, &quot;a&quot;, start = 13)
 s2, b = textslider(-20f0:20f0, &quot;b&quot;, start = 10)
 s3, c = textslider(0f0:20f0, &quot;c&quot;, start = 2)
 s4, d = textslider(range(0.0, stop = 0.02, length = 100), &quot;d&quot;, start = 0.01)
 s5, scales = textslider(range(0.01, stop = 0.5, length = 100), &quot;scale&quot;, start = 0.1)
 s6, colorsw, pop = colorswatch()

 function lorenz(t0, a, b, c, h)
     Point3f0(
         t0[1] + h * a * (t0[2] - t0[1]),
         t0[2] + h * (t0[1] * (b - t0[3]) - t0[2]),
         t0[3] + h * (t0[1] * t0[2] - c * t0[3]),
     )
 end
 # step through the `time`
 function lorenz(array::Vector, a = 5.0 ,b = 2.0, c = 6.0, d = 0.01)
     t0 = Point3f0(0.1, 0, 0)
     for i = eachindex(array)
         t0 = lorenz(t0, a,b,c,d)
         array[i] = t0
     end
     array
 end
 n1, n2 = 18, 30
 N = n1*n2
 args_n = (a, b, c, d)
 v0 = lorenz(zeros(Point3f0, N), to_value.(args_n)...)
 positions = lift(lorenz, Node(v0), args_n...)
 rotations = lift(diff, positions)
 rotations = lift(x-&gt; push!(x, x[end]), rotations)

 mesh_scene = meshscatter(
     positions,
     markersize = scales, rotation = rotations,
     intensity = collect(range(0f0, stop = 1f0, length = length(positions[]))),
     color = colorsw
 )
 parent = Scene(resolution = (1000, 800))
 vbox(
     hbox(s1, s2, s3, s4, s5, s6),
     mesh_scene, parent = parent
 )
 RecordEvents(parent, &quot;./docs/media/gui_for_exploring_lorenz_equation&quot;)

</code></pre>    <video controls autoplay loop muted>
      <source src="media\gui_for_exploring_lorenz_equation.mp4" type="video/mp4">
      Your browser does not support mp4. Please use a modern browser like Chrome or Firefox.
    </video><h2><a class="nav-anchor" id="Type-recipe-for-molecule-simulation-1" href="#Type-recipe-for-molecule-simulation-1">Type recipe for molecule simulation</a></h2><p>Tags: <code>linesegments</code>, <code>meshscatter</code>, <code>molecules</code>, <code>recipe</code>.</p><pre><code class="language-julia">using Makie
 import AbstractPlotting: Plot, default_theme, plot!, to_value
 using Makie


 struct Simulation
     grid::Vector{Point3f0}
 end
 # Probably worth having a macro for this!
 function default_theme(scene::SceneLike, ::Type{&lt;: Plot(Simulation)})
     Theme(
         advance = 0,
         molecule_sizes = [0.08, 0.04, 0.04],
         molecule_colors = [:maroon, :deepskyblue2, :deepskyblue2]
     )
 end

 # The recipe! - will get called for plot(!)(x::SimulationResult)
 function AbstractPlotting.plot!(p::Plot(Simulation))
     sim = to_value(p[1]) # first argument is the SimulationResult
     # when advance changes, get new positions from the simulation
     mpos = lift(p[:advance]) do i
         sim.grid .+ rand(Point3f0, length(sim.grid)) .* 0.01f0
     end
     # size shouldn&#39;t change, so we might as well get the value instead of signal
     pos = to_value(mpos)
     N = length(pos)
     sizes = lift(p[:molecule_sizes]) do s
         repeat(s, outer = N ÷ 3)
     end
     sizes = lift(p[:molecule_sizes]) do s
         repeat(s, outer = N ÷ 3)
     end
     colors = lift(p[:molecule_colors]) do c
         repeat(c, outer = N ÷ 3)
     end
     scene = meshscatter!(p, mpos, markersize = sizes, color = colors)
     indices = Int[]
     for i in 1:3:N
         push!(indices, i, i + 1, i, i + 2)
     end
     meshplot = p.plots[end] # meshplot is the last plot we added to p
     # meshplot[1] -&gt; the positions (first argument) converted to points, so
     # we don&#39;t do the conversion 2 times for linesegments!
     linesegments!(p, lift(x-&gt; view(x, indices), meshplot[1]))
 end

 # To write out a video of the whole simulation
 n = 5
 r = range(-1, stop = 1, length = n)
 grid = Point3f0.(r, reshape(r, (1, n, 1)), reshape(r, (1, 1, n)))
 molecules = map(1:(n^3) * 3) do i
     i3 = ((i - 1) ÷ 3) + 1
     xy = 0.1; z = 0.08
     i % 3 == 1 &amp;&amp; return grid[i3]
     i % 3 == 2 &amp;&amp; return grid[i3] + Point3f0(xy, xy, z)
     i % 3 == 0 &amp;&amp; return grid[i3] + Point3f0(-xy, xy, z)
 end
 result = Simulation(molecules)
 scene = plot(result)
 N = 100
 record(scene, &quot;./docs/media/type_recipe_for_molecule_simulation.mp4&quot;, 1:N) do i
     scene[end][:advance] = i
end

</code></pre>    <video controls autoplay loop muted>
      <source src="media\type_recipe_for_molecule_simulation.mp4" type="video/mp4">
      Your browser does not support mp4. Please use a modern browser like Chrome or Firefox.
    </video><footer><hr/><a class="previous" href="examples-mesh.html"><span class="direction">Previous</span><span class="title"><code>mesh</code></span></a><a class="next" href="examples-scatter.html"><span class="direction">Next</span><span class="title"><code>scatter</code></span></a></footer></article></body></html>
